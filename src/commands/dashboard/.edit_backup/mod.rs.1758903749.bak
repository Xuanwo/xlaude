use anyhow::{Context, Result};
use crossterm::{
    event::{self, Event, KeyEvent},
    execute,
    terminal::{disable_raw_mode, enable_raw_mode, EnterAlternateScreen, LeaveAlternateScreen},
};
use ratatui::{Terminal, backend::CrosstermBackend};
use std::io;
use std::time::Duration;

use crate::state::XlaudeState;
use crate::tmux::TmuxManager;

mod dialogs;
mod input;
mod state;
mod ui;
mod worktree_manager;

use input::{handle_input, InputResult};
use state::DashboardState;
use worktree_manager::WorktreeManager;

pub struct Dashboard {
    state: DashboardState,
    xlaude_state: XlaudeState,
    worktree_manager: WorktreeManager,
}

impl Dashboard {
    pub fn new() -> Result<Self> {
        Ok(Dashboard {
            state: DashboardState::new(),
            xlaude_state: XlaudeState::load()?,
            worktree_manager: WorktreeManager::new(),
        })
    }

    pub fn run(&mut self) -> Result<()> {
        enable_raw_mode()?;
        let mut stdout = io::stdout();
        execute!(stdout, EnterAlternateScreen)?;
        let backend = CrosstermBackend::new(stdout);
        let mut terminal = Terminal::new(backend)?;

        self.refresh()?;

        let result = self.run_loop(&mut terminal);

        disable_raw_mode()?;
        execute!(terminal.backend_mut(), LeaveAlternateScreen)?;
        terminal.show_cursor()?;

        result
    }

    fn run_loop(&mut self, terminal: &mut Terminal<CrosstermBackend<io::Stdout>>) -> Result<()> {
        loop {
            let sessions = self.worktree_manager.list_sessions().unwrap_or_default();
            terminal.draw(|f| ui::render(f, &mut self.state, &sessions))?;

            self.state.update_status_timer();

            if event::poll(Duration::from_millis(500))? {
                if let Event::Key(key) = event::read()? {
                    match self.handle_event(key)? {
                        InputResult::Exit => break,
                        InputResult::Attach(project) => {
                            self.handle_attach(&mut terminal, &project)?;
                        }
                        InputResult::CreateWorktree(name, repo) => {
                            self.handle_create_worktree(name, repo)?;
                        }
                        InputResult::Continue => {}
                    }
                }
            } else {
                self.refresh()?;
            }
        }
        Ok(())
    }

    fn handle_event(&mut self, key: KeyEvent) -> Result<InputResult> {
        let result = handle_input(key, &mut self.state, &mut self.xlaude_state)?;

        // Handle actions that require worktree manager
        if let crossterm::event::KeyCode::Char('d' | 'D') = key.code {
            if let Some(worktree) = self.state.get_selected_worktree() {
                if worktree.has_session {
                    self.worktree_manager.kill_session(&worktree.name)?;
                    self.refresh()?;
                }
            }
        }

        if let crossterm::event::KeyCode::Char('r' | 'R') = key.code {
            self.refresh()?;
        }

        Ok(result)
    }

    fn handle_attach(
        &mut self,
        terminal: &mut Terminal<CrosstermBackend<io::Stdout>>,
        project: &str,
    ) -> Result<()> {
        let worktree = self
            .state
            .worktrees
            .iter()
            .find(|w| w.name == project)
            .context("Worktree not found")?;

        let info = self
            .xlaude_state
            .worktrees
            .get(&worktree.key)
            .context("Worktree info not found")?;

        if !info.path.exists() {
            anyhow::bail!("Worktree path does not exist: {}", info.path.display());
        }

        disable_raw_mode()?;
        execute!(terminal.backend_mut(), LeaveAlternateScreen)?;
        terminal.show_cursor()?;

        if !self.worktree_manager.session_exists(project) {
            println!("Creating new tmux session for {}...", project);
            self.worktree_manager.create_session(project, &info.path)?;
            std::thread::sleep(Duration::from_millis(500));
        }

        self.worktree_manager.attach_session(project)?;

        enable_raw_mode()?;
        execute!(terminal.backend_mut(), EnterAlternateScreen)?;
        terminal.hide_cursor()?;
        terminal.clear()?;

        self.refresh()?;
        Ok(())
    }

    fn handle_create_worktree(
        &mut self,
        name: Option<String>,
        repo: Option<String>,
    ) -> Result<()> {
        let repo_path = if let Some(repo_name) = &repo {
            self.find_repo_path(repo_name)
        } else {
            None
        };

        match crate::commands::create::handle_create_in_dir_quiet(name, repo_path, true) {
            Ok(created_name) => {
                self.refresh()?;

                if let Some(repo_name) = repo {
                    let key = format!("{}/{}", repo_name, created_name);
                    self.state.focus_on_worktree(&created_name);
                }

                self.state
                    .set_status_message(format!("âœ… Created worktree: {}", created_name));
            }
            Err(e) => {
                self.state
                    .set_status_message(format!("Failed to create worktree: {}", e));
            }
        }
        Ok(())
    }

    fn find_repo_path(&self, repo_name: &str) -> Option<std::path::PathBuf> {
        if let Some(worktree) = self.state.worktrees.iter().find(|w| w.repo == *repo_name) {
            if let Some(info) = self.xlaude_state.worktrees.get(&worktree.key) {
                if let Some(parent) = info.path.parent() {
                    let path = parent.join(repo_name);
                    if path.exists() {
                        return Some(path);
                    }
                }
            }
        }
        None
    }

    fn refresh(&mut self) -> Result<()> {
        self.xlaude_state = XlaudeState::load()?;
        let sessions = self.worktree_manager.list_sessions().unwrap_or_default();

        self.worktree_manager.refresh_worktrees(
            &mut self.state,
            &self.xlaude_state,
            &sessions,
        );

        let updated_sessions = self.worktree_manager.list_sessions().unwrap_or_default();
        self.worktree_manager.update_claude_statuses(
            &mut self.state,
            &self.xlaude_state,
            &updated_sessions,
        );

        Ok(())
    }
}

pub fn handle_dashboard() -> Result<()> {
    if !TmuxManager::is_available() {
        anyhow::bail!(
            "tmux is not installed. Please install tmux to use the dashboard feature.\n\
             On macOS: brew install tmux\n\
             On Ubuntu/Debian: apt-get install tmux"
        );
    }

    let mut dashboard = Dashboard::new()?;
    dashboard.run()?;

    Ok(())
}